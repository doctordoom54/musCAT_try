classdef True_SC_RWA_Actuator < handle
    %   REACTION_WHEEL_ACTUATOR Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        
        num_reaction_wheel                  % number of reaction wheel
        
        time_step                           % control time step
        
        flag_desat_in_process
        
        desired_desat_control_torque
        
        optimization_otpions
        
        RW_data
        %             – # name = ‘Reaction Wheel i’
        %             – health : Health of ith Reaction Wheel
        %             0. Switched off
        %             1. Switched on, works nominally
        %             – temperature [deg C] : Temperature of ith Reaction Wheel
        %             – # instantaneous_power_consumed [Watts] : Instantaneous power consumed by ith
        %             Reaction Wheel (if it is switched on)
        %             – # instantaneous_data_generated [kb] : Data generated during the current time step,
        %             in kilo bits (kb)
        %             – # control_torque_RW [Nm] : Control torque about Center of Mass of SC, generated by
        %             ith Reaction Wheel
        %             – #angle [rad] : Euler angle describing this RW implementation in body frame B
        %             – #rotation_matrix [rad] : rotation matrix from body frame B to RW frame.
        %             – #direction [rad] : rotation axis x_rw in body frame B.
        %             – location [m] : Location of actuator, in body frame B
        %             – mass [kg] : Reaction wheel’s mass
        %             – radius [m] : Reaction wheel’s radius
        %             – # moment_of_inertia [kg m^2] : Reaction wheel’s MI matrix in body frame B2
        %             – true_angular_velocity [rad/sec] : True angular velocity of reaction wheel.
        %             – angular_velocity_noise [rad/sec^2] : Noise added to each dimension of
        %             true_angular_velocity while measuring it.
        %             – # measured_angular_velocity [rad/sec] : Noise added to true_angular_velocity,
        %             and is sent to the SC’s software.
        %             – maximum_angular_velocity [rad/sec] : True angular velocity of reaction wheel.
        %             – # commanded_angular_acceleration [rad/sec^2] : Comes from the SC’s software
        %             – # angular_acceleration_noise [rad/sec^2] : Noise added to each dimension of
        %             commanded_angular_acceleration. It is derived from angular_velocity_noise
        %             – # true_angular_acceleration [rad/sec^2] : Add noise to
        %             commanded_angular_acceleration. This is the actual angular acceleration of the reac-
        %             tion wheel, which the SC software doesn’t know.
        %             – power_consumed_angular_velocity_array : Initialize array of power consumed and
        %             angular velocity variables, used to calculate instantaneous_power_consumed_rw
        
        optimization_data
        envelope_ratio
        rw_maximum_torque
        rw_momentum_capacity
        rw_maximum_acceleration
    end
    
    methods
        
        %% class builder
        function obj = True_SC_RWA_Actuator(sc_data, True_time, mission_true_SC)
            %MICRO_THRUSTER_ACTUATOR Construct an instance of this class
            %   Detailed explanation goes here
            
            obj.num_reaction_wheel = sc_data.num_reaction_wheel;
            
            obj.time_step = True_time.time_step;
            
            obj.flag_desat_in_process = 0;
            
            obj.desired_desat_control_torque = zeros(3,1);
            
            % SC CM position
            r_CM_SC = mission_true_SC.true_SC_body.location_center_of_mass;
            
            for i=1:obj.num_reaction_wheel
                obj.RW_data(i).health = 1;                              % [boolean] : 1=ok / 0=nok
                obj.RW_data(i).temperature = 20;                        % [deg C]
                obj.RW_data(i).radius = sc_data.rw_radius;
                obj.RW_data(i).mass = sc_data.rw_mass;
                obj.RW_data(i).maximum_angular_velocity = sc_data.rw_maximum_angular_velocity;
                obj.RW_data(i).commanded_angular_acceleration = 0;      % [rad/s^2] acceleration command
                obj.RW_data(i).true_angular_acceleration = 0;           % [rad/s^2] true acceleration with noise
                obj.RW_data(i).commanded_control_torque_RW = [0 0 0]';  % [N.m] Commanded control torque
                obj.RW_data(i).true_control_torque_RW = [0 0 0]';       % [N.m] True control torque
                obj.RW_data(i).angular_velocity_noise = sc_data.rw_angular_velocity_noise;
                obj.RW_data(i).angular_acceleration_noise = obj.RW_data(i).angular_velocity_noise/True_time.time_step;  % [rad/s^2] acc noise = omega_noise/time_step
                obj.RW_data(i).true_angular_velocity = 0;               % [rad/s] true angular velocity with noise
                obj.RW_data(i).measured_angular_velocity = 0;           % [rad/s] true velocity with meqsurement noise
                obj.RW_data(i).angle = sc_data.rw_angle_array(i,:); % [rad] angle of RW in SC frame
                obj.RW_data(i).rotation_matrix = eul2rotm(obj.RW_data(i).angle); % Rotation matrix
                obj.RW_data(i).direction = obj.RW_data(i).rotation_matrix*[1 0 0]'; % [unit vector] direction axis of RW
                
                if isfield(sc_data, 'initial_momentum_percentage')
                    obj.RW_data(i).true_angular_velocity = obj.RW_data(i).maximum_angular_velocity ...
                        * sc_data.initial_momentum_percentage / 100;
                end
                
                obj.RW_data(i).location = sc_data.rw_position(i, :)'; % [m] location of RW in SC frame
                if isfield(sc_data, 'rw_shape_models')
                    obj.RW_data(i).shape_model = sc_data.rw_shape_models{i};
                end
                
                if isfield(sc_data, 'rw_momentum_capacity')
                    J_i_tmp = sc_data.rw_momentum_capacity / obj.RW_data(i).maximum_angular_velocity;
                    J_rw = diag([J_i_tmp, J_i_tmp/2, J_i_tmp/2]);
                else
                    % Inertia matrix in RW frame
                    J_rw = diag([
                        1/2*obj.RW_data(i).mass*obj.RW_data(i).radius^2;
                        1/4*obj.RW_data(i).mass*obj.RW_data(i).radius^2;
                        1/4*obj.RW_data(i).mass*obj.RW_data(i).radius^2]);
                end
                
                obj.RW_data(i).J_xx = J_rw(1,1);
                
                % Rotation from RW frame to this SC frameS
                R = obj.RW_data(i).rotation_matrix;
                J_rw_rot = R*J_rw*R';
                
                % Displacement vector from the shape CM to the SC CM
                %r_CM_i = r_CM_SC - obj.RW_data(i).location;
                
                % Parallel axis theorem
                %J_sc = J_rw_rot + obj.RW_data(i).mass*(r_CM_i' * r_CM_i * eye(3) - r_CM_i * r_CM_i');
                
                obj.RW_data(i).moment_of_inertia = J_rw_rot;
                
                obj.RW_data(i).power_consumed_angular_velocity_array = sc_data.rw_power_consumed_angular_velocity_array;
                obj.RW_data(i).instantaneous_power_consumed = 0;
                obj.RW_data(i).instantaneous_data_volume = sc_data.rw_instantaneous_data_volume;
                obj.RW_data(i).instantaneous_data_generated = 0;
                obj.RW_data(i).failure_deceleration = 0.05;
                
                obj.optimization_otpions = optimoptions('linprog');
                obj.optimization_otpions.Display = 'off';
                
                % Desaturation max torque
                if (sc_data.flag_hardware_exists.adc_micro_thruster == 1)
                    
                    obj.RW_data(i).maximum_MT_desat_torque = [0 0]; % [min torque ; max torque]
                    for j=1:mission_true_SC.true_SC_micro_thruster_actuator.num_micro_thruster
                        % torque of j^th MT in this i^th RW frame
                        MT_data_j = mission_true_SC.true_SC_micro_thruster_actuator.MT_data(j);
                        this_MT_torque = obj.RW_data(i).rotation_matrix * ( ...
                            cross(MT_data_j.location, MT_data_j.orientation) * MT_data_j.maximum_thrust ...
                            ) / obj.num_reaction_wheel;
                        if (this_MT_torque(1) > 1e-3)
                            obj.RW_data(i).maximum_MT_desat_torque(2) = obj.RW_data(i).maximum_MT_desat_torque(2) + this_MT_torque(1);
                        elseif (this_MT_torque(1) < 1e-3)
                            obj.RW_data(i).maximum_MT_desat_torque(1) = obj.RW_data(i).maximum_MT_desat_torque(1) + this_MT_torque(1);
                        else
                            % no torque possible by this MT on this RW axis
                        end
                    end
                    
                end
            end
            
            obj.optimization_data = [];
            
            % Torque envelope
            if isfield(sc_data, 'rw_maximum_torque')
                % Maximum Torque and Momentum Envelopes for Reaction Wheel Arrays
                % https://ntrs.nasa.gov/api/citations/20110015369/downloads/20110015369.pdf
                assert(ismember(obj.num_reaction_wheel, [3 4 5 6]), 'Number of reaction wheel must be 3, 4, 5 or 6')
                switch obj.num_reaction_wheel
                    case 3
                        d_min = 1; % d_12
                    case 4
                        d_min = 1.633; % d_12 = d_13
                    case 5
                        d_min = 5/8 * 2.667; % d_24 = d_42
                    case 6
                        d_min = 2.667; % d_23
                end
                obj.envelope_ratio = d_min;
                obj.rw_maximum_torque = sc_data.rw_maximum_torque;
                obj.rw_momentum_capacity = sc_data.rw_momentum_capacity;
                obj.rw_maximum_acceleration = sc_data.rw_maximum_torque / obj.RW_data(1).J_xx;
            else
                obj.envelope_ratio = 1;
                obj.rw_maximum_torque = Inf;
                obj.rw_momentum_capacity = Inf;
                obj.rw_maximum_acceleration = Inf;
            end
        end
        
        function obj = func_initialize_optimization_data(obj)
        end
        
        %% RWA attitude control function
        function obj = func_compute_rw_command(obj,SC_control_attitude,Software_SC_Estimate_Attitude)
            
            % reset
            for i=1:obj.num_reaction_wheel
                % i^th RW torque
                obj.RW_data(i).commanded_control_torque_RW = zeros(3,1);
                %i^th RW acceleration command
                obj.RW_data(i).commanded_angular_acceleration = 0;
            end
            
            if norm(SC_control_attitude.desired_control_torque_RWA) > 0
                
                N = obj.num_reaction_wheel;
                n = 4*N; % number of variables
                p = 3*(N+1); % number of constraints
                
                d = zeros(p,1); % constraint vector
                for i=1:N
                    idx1 = (i-1)*3+1;
                    idx2 = (i-1)*3+3;
                    d(idx1:idx2,1) = Software_SC_Estimate_Attitude.dot_angular_velocity;
                end
                
                % Scale desired torque vector
                torque_desired = SC_control_attitude.desired_control_torque_RWA;
                if obj.rw_maximum_torque < Inf
                    factor = min(1, (obj.rw_maximum_torque * obj.envelope_ratio) / norm(torque_desired));
                    % time_between_desats = 0.5 * 3600; % [s]
                    % torque_max = obj.rw_momentum_capacity / time_between_desats;
                    % factor = min(1, torque_max / norm(torque_desired));
                else
                    factor = 1;
                end
                
                d(3*N+1:p,1) = factor * torque_desired;
                
                objective = 'acceleration';
                switch objective
                    case 'acceleration'
                        A = diag([zeros(3*N,1); ones(n - 3*N,1)]);
                        b = zeros(n,1);
                    case 'momentum'
                        omega = [obj.RW_data.true_angular_velocity]';
                        alpha_max = obj.rw_maximum_acceleration;
                        A = diag([zeros(3*N,1); ones(n - 3*N,1)]);
                        b = [zeros(3*N,1); -sign(omega).*min(alpha_max, abs(omega)/obj.time_step)];
                end
                
                if isempty(obj.optimization_data)
                    
                    C = zeros(p,n); % constraint matrix
                    for i=1:N
                        idx1 = (i-1)*3+1;
                        idx2 = (i-1)*3+3;
                        R = obj.RW_data(i).rotation_matrix;
                        
                        C(idx1:idx2,idx1:idx2) = inv(obj.RW_data(i).moment_of_inertia);
                        C(idx1:idx2,3*N+i) = -R(:,1);
                        C(3*N+1:p,idx1:idx2) = eye(3,3);
                    end
                    
                    % Solve optimization problem (constrained least squares)
                    % min ||Ax - b||_2^2  s.t. Cx = d
                    
                    % Form Karush-Kuhn-Tucker (KKT) system
                    O = zeros(p,p);
                    E = [A'*A C'; C O];
                    [L,U,P] = lu(E);
                    
                    % Save data
                    obj.optimization_data.C = C;
                    obj.optimization_data.L = L;
                    obj.optimization_data.U = U;
                    obj.optimization_data.P = P;
                else
                    % Load data
                    C = obj.optimization_data.C;
                    L = obj.optimization_data.L;
                    U = obj.optimization_data.U;
                    P = obj.optimization_data.P;
                end
                
                f = [A'*b; d];
                
                % Efficient solve
                xz = U\(L\(P*f));
                x = xz(1:n);
                
                if false
                    % Naive solve
                    xz = E\f;
                    x = xz(1:n);
                end
                
                if false
                    if N == 3
                        % Solve matrix equation
                        x = C\d;
                    else
                        % Solve linear program
                        x = linprog(diag(A),[],[],C,d,[],[],obj.optimization_otpions);
                    end
                end
                
                assert (norm(C*x-d) < 1e-6, 'Error in RW optimization');
                
                % results storing
                for i=1:N
                    idx1 = (i-1)*3+1;
                    idx2 = (i-1)*3+3;
                    % i^th RW torque
                    obj.RW_data(i).commanded_control_torque_RW = x(idx1:idx2);
                    %i^th RW acceleration command
                    obj.RW_data(i).commanded_angular_acceleration = x(3*N+i,1);
                end
                
            end
            
        end
        
        
        function obj = func_dynamics_reaction_wheel(obj, true_SC_adc)
            
            for i=1:obj.num_reaction_wheel
                
                if (obj.RW_data(i).health == 1)   % RW HEALTH OK
                    % acceleration
                    obj.RW_data(i).true_angular_acceleration = obj.RW_data(i).commanded_angular_acceleration + obj.RW_data(i).angular_acceleration_noise*(-1 + 2.*rand(1))'; %true acc with noise
                    
                    if(abs(obj.RW_data(i).true_angular_velocity)>=obj.RW_data(i).maximum_angular_velocity)
                        obj.RW_data(i).true_angular_acceleration = 0;
                    end
                    
                    % True torque
                    RW_ACC_SC = obj.RW_data(i).true_angular_acceleration*obj.RW_data(i).direction;    % [rad.s-2] trueacceleration in SC frame
                    obj.RW_data(i).true_control_torque_RW = obj.RW_data(i).moment_of_inertia*(RW_ACC_SC + true_SC_adc.dot_angular_velocity); % [N.m] Torque resulting in SC frame
                    
                    % Power values
                    obj.RW_data(i).instantaneous_power_consumed =  interp1(obj.RW_data(i).power_consumed_angular_velocity_array(2,:),obj.RW_data(i).power_consumed_angular_velocity_array(1,:),abs(obj.RW_data(i).true_angular_velocity));
                    % Data values
                    obj.RW_data(i).instantaneous_data_generated = obj.RW_data(i).instantaneous_data_volume;
                    
                elseif (obj.RW_data(i).health == 0)   % RW HEALTH NOT OK
                    % This RW is in failure case
                    if abs(obj.RW_data(i).true_angular_velocity)>=obj.RW_data(i).failure_deceleration*obj.time_step
                        obj.RW_data(i).true_angular_acceleration = -1*sign(obj.RW_data(i).true_angular_velocity)*obj.RW_data(i).failure_deceleration; % slowly decelerates until 0 velocity
                    else
                        obj.RW_data(i).true_angular_acceleration = 0;
                    end
                    
                    % True torque
                    RW_ACC_SC = obj.RW_data(i).true_angular_acceleration*obj.RW_data(i).direction;    % [rad.s-2] trueacceleration in SC frame
                    obj.RW_data(i).true_control_torque_RW = obj.RW_data(i).moment_of_inertia*(RW_ACC_SC + true_SC_adc.dot_angular_velocity); % [N.m] Torque resulting in SC frame
                    
                    % Power values
                    obj.RW_data(i).instantaneous_power_consumed = 0;
                    % Data values
                    obj.RW_data(i).instantaneous_data_generated = 0; % [kb]
                end
                
                % True velocity
                obj.RW_data(i).true_angular_velocity = obj.RW_data(i).true_angular_velocity + obj.RW_data(i).true_angular_acceleration*obj.time_step;
                
                if obj.RW_data(i).true_angular_velocity > obj.RW_data(i).maximum_angular_velocity
                    obj.RW_data(i).true_angular_velocity = obj.RW_data(i).maximum_angular_velocity;
                elseif obj.RW_data(i).true_angular_velocity < -obj.RW_data(i).maximum_angular_velocity
                    obj.RW_data(i).true_angular_velocity = -obj.RW_data(i).maximum_angular_velocity;
                else
                    % Do nothing!
                end
                
                obj.RW_data(i).measured_angular_velocity = obj.RW_data(i).true_angular_velocity + normrnd(0,obj.RW_data(i).angular_velocity_noise); % [rad.s-1] measured velocity with noise
                
            end
            
        end
        
        function obj = function_compute_RWA_DeSat_torque(obj,SC_estimate_attitude)
            
            obj.desired_desat_control_torque = zeros(3,1);
            
            desat_until = 10; % [RPM] threshold
            
            % ---> Apply deceleration inverse proportionnal to current velocity
            % -> apply a deceleration on RWA according to what torque
            % MT can counteract. Save a torque margin of 20% on MT for them to continue perform attitude control
            Kp = 1;
            desat_margin = 0.5;
            
            obj.flag_desat_in_process = 0;
            
            for i=1:obj.num_reaction_wheel
                
                obj.RW_data(i).commanded_angular_acceleration = 0;
                obj.RW_data(i).commanded_control_torque_RW = zeros(3,1);
                
                SC_acc_RW = inv(obj.RW_data(i).moment_of_inertia) * SC_estimate_attitude.dot_angular_velocity;
                
                max_acc = desat_margin * obj.RW_data(i).maximum_MT_desat_torque/obj.RW_data(i).moment_of_inertia(1,1);% - SC_acc_RW(1);
                max_acc = min(min(abs(max_acc)), obj.rw_maximum_acceleration)*[-1 +1];
                
                if abs(obj.RW_data(i).true_angular_velocity)>=desat_until*2*pi/60 && obj.RW_data(i).health == 1
                    
                    obj.flag_desat_in_process = 1;
                    
                    % cmd = -Kp * obj.RW_data(i).true_angular_velocity; % apply deceleration inverse proportional to velocity
                    cmd = -Kp * obj.RW_data(i).true_angular_velocity / obj.time_step;
                    
                    if cmd > max_acc(2)
                        cmd  = max_acc(2);
                    elseif cmd < max_acc(1)
                        cmd = max_acc(1);
                    else
                        % Do nothing!
                    end
                    obj.RW_data(i).commanded_angular_acceleration = cmd;
                    
                    % Get torque from reaction wheel
                    RW_ACC_SC =  obj.RW_data(i).commanded_angular_acceleration*obj.RW_data(i).direction;    % get acc in SC frame
                    obj.RW_data(i).commanded_control_torque_RW =  obj.RW_data(i).moment_of_inertia*(RW_ACC_SC + SC_estimate_attitude.dot_angular_velocity); %Torque resulting from RWA in SC frame
                    obj.desired_desat_control_torque = obj.desired_desat_control_torque + obj.RW_data(i).commanded_control_torque_RW;
                    
                else
                    %do nothing
                end
                
            end
            
            
        end
        
        function h_w = func_calc_true_rw_momentum(obj)
            % Momentum vector associated with the reaction wheels
            h_w = [obj.RW_data.J_xx]' .* ...
                [obj.RW_data.direction]' .* ...
                [obj.RW_data.true_angular_velocity]';
            h_w = sum(h_w,1)' * 0;
        end
        
        function h_w = func_calc_meas_rw_momentum(obj)
            % Momentum vector associated with the reaction wheels
            h_w = [obj.RW_data.J_xx]' .* ...
                [obj.RW_data.direction]' .* ...
                [obj.RW_data.measured_angular_velocity]';
            h_w = sum(h_w,1)' * 0;
        end
    end
end

