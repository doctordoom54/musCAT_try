classdef True_SC_Micro_Thruster_Actuator < handle
    %MICRO_THRUSTER_ACTUATOR Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        
        time
        
        num_micro_thruster
        
        MT_data
        %             – health : Health of ith Micro Thruster
        %                 0. Switched off
        %                 1. Switched on, works nominally
        %             – temperature [deg C] : Temperature of ith Micro Thruster
        %             – # instantaneous_power_consumed [Watts] : Instantaneous power consumed by ith
        %                 Micro Thruster (if it is switched on)
        %             – # instantaneous_data_generated [kb] : Data generated during the current time step,
        %                 in kilo bits (kb)
        %             – # control_force_MT [N] : Control force vector generated by ith Micro Thruster that
        %                 passes through Center of Mass of SC
        %             – # control_torque_MT [Nm] : Control torque about Center of Mass of SC, generated by
        %                 ith Micro Thruster
        %             – thruster_warm_up_time [sec] : How much warm-up time is needed?
        %             – thruster_warm_up_power_consumed [Watts] : Power consumed during warmup time
        %             – # accumulated_warm_up_time = 0 [sec]
        %             – # command_actuation [Boolean] : 1 = Command actuation during this time step (after
        %                 actuator has warmed up)
        %             – command_actuation_power_consumed [Watts] : Power consumed during actuation
        %             – orientation [unit vector] : Normal vector of thrust in body frame B
        %             – location [m] : Location of actuator, in body frame B
        %             – maximum_thrust [N]
        %             – minimum_thrust [N] : This need not be 0
        %             – # commanded_thrust [N] : Comes from the SC’s software
        %             – thruster_noise [N] : Added to every dimension of commanded_thrust
        %             – # true_commanded_thrust [N] : Add thruster noise to commanded_thrust. This is the
        %                 actual thrust of this thruster, which the SC software doesn’t know.
        %             – # command_executed [Boolean] : 1 = Command executed during this time step
        %             – # command_time [sec] : Time when latest Command was actuated
        
        optim_data % Data for optimization
        
    end
    
    methods
        function obj = True_SC_Micro_Thruster_Actuator(sc_body_init_data, mission_true_time, true_SC_body)
            %MICRO_THRUSTER_ACTUATOR Construct an instance of this class
            %   Detailed explanation goes here
            
            obj.time = mission_true_time.time;
            
            obj.num_micro_thruster = sc_body_init_data.num_micro_thruster;
            
            for i=1:obj.num_micro_thruster
                
                obj.MT_data(i).health = 1;                                                          % [boolean] : 1=ok / 0=nok
                obj.MT_data(i).temperature = 20;                                                    % [deg C]
                obj.MT_data(i).instantaneous_power_consumption = sc_body_init_data.micro_thruster_instantaneous_power_consumption(i);
                obj.MT_data(i).instantaneous_power_consumed = 0;                                    % [Watts]
                obj.MT_data(i).instantaneous_data_volume = sc_body_init_data.micro_thruster_instantaneous_data_volume;
                obj.MT_data(i).instantaneous_data_generated = 0;                                    % [kb]
                obj.MT_data(i).control_force_MT = [0 0 0]';                                         % [N]
                obj.MT_data(i).control_torque_MT = [0 0 0]';                                        % [Nm]
                obj.MT_data(i).thruster_warm_up_time = 0;                                           % [sec]
                obj.MT_data(i).thruster_warm_up_power_consumed= 0;                                  % [Watts]
                obj.MT_data(i).accumulated_warm_up_time = 0;                                        % [sec]
                obj.MT_data(i).command_actuation = 0;                                               % [Boolean]
                obj.MT_data(i).command_actuation_power_consumed = 0;                                % [Watts]
                obj.MT_data(i).orientation = sc_body_init_data.micro_thruster_direction_array(i,:)';% [unit vector]
                obj.MT_data(i).location = sc_body_init_data.micro_thruster_position_array(i,:)';    % [m]
                obj.MT_data(i).maximum_thrust = sc_body_init_data.micro_thruster_maximum_thrust(i);
                obj.MT_data(i).minimum_thrust = 0;                                                  % [N]
                obj.MT_data(i).commanded_thrust = [0 0 0]';                                         % [N]
                obj.MT_data(i).commanded_torque = [0 0 0]';                                         % [Nm]
                obj.MT_data(i).thruster_noise = sc_body_init_data.micro_thruster_thruster_noise(i);
                obj.MT_data(i).true_commanded_thrust = [0 0 0]';                                    % [N]
                obj.MT_data(i).command_executed = 0;                                                % [Boolean]
                obj.MT_data(i).command_time = 0;                                                    % [sec]
                obj.MT_data(i).ISP = sc_body_init_data.micro_thruster_ISP(i);                          % [sec]
                obj.MT_data(i).mass_propelant_used = 0 ;                                            % [kg]
                
                obj.MT_data(i).thruster_input_array = round(cross(obj.MT_data(i).location - true_SC_body.location_center_of_mass, obj.MT_data(i).orientation), 3);
                
            end
            
            obj = obj.func_initialize_optimization_data();
            
        end
        
        function obj = func_decompose_control_torque_into_thrusters_optimization(obj,SC_control_attitude)
            
            % reset
            for j=1:1:obj.num_micro_thruster
                obj.MT_data(j).commanded_thrust = 0;
                obj.MT_data(j).commanded_torque = zeros(3,1);
            end
            
            thruster_input_matrix = [obj.MT_data.thruster_input_array];
            thruster_direction_array = [obj.MT_data.orientation];
            
            % Decompose Torque to Create Thrust Array inputs using Optimization
            cvx_begin quiet
            variable x(obj.num_micro_thruster,1)
            minimize( norm( thruster_direction_array*x ) )
            subject to
            x >= 0
            thruster_input_matrix*x == SC_control_attitude.desired_control_torque_MT
            cvx_end
            
            for i=1:1:obj.num_micro_thruster
                obj.MT_data(i).commanded_thrust = x(i);
                obj.MT_data(i).commanded_torque = obj.MT_data(i).thruster_input_array*obj.MT_data(i).commanded_thrust;
            end
        end
        
        function obj = func_initialize_optimization_data(obj)
            % Assumption: the thrust of each microthruster can be compensated with
            % that of another one
            
            thruster_input_matrix = [obj.MT_data.thruster_input_array]';
            
            % Step 1. Find MT with the SAME resultant torque
            N_mt = obj.num_micro_thruster;
            flag_mt_checked = zeros(N_mt,1); % Flag to remove checked MTs
            idxs_bool_same_torque = [];      % MTs with SAME torque
            matrix_same_torque = [];         % Reduced input matrix
            for i_mt = 1:N_mt
                if flag_mt_checked(i_mt)
                    continue
                end
                torque_dir_i = thruster_input_matrix(i_mt,:); % This MT torque direction
                idxs_bool = ismember(thruster_input_matrix, torque_dir_i, 'rows'); % MTs with the SAME torque direction
                
                matrix_same_torque = [matrix_same_torque; torque_dir_i]; % Append torque direction
                idxs_bool_same_torque = [idxs_bool_same_torque; idxs_bool']; % Append MT indexes
                flag_mt_checked(idxs_bool) = 1; % Flag as checked
            end
            idxs_bool_same_torque = boolean(idxs_bool_same_torque);
            
            % Step 2. Find MT with OPPOSITE resultants torques
            N_mt_same = size(matrix_same_torque, 1);
            flag_mt_checked = zeros(N_mt,1); % Flag to remove checked MTs
            idxs_num_opposite_torque = [];  % MTs with OPPOSITE torque
            matrix_opposite_torque = [];     % Reduced input matrix
            for i_mt = 1:N_mt_same
                if flag_mt_checked(i_mt)
                    continue
                end
                torque_dir_i = matrix_same_torque(i_mt,:); % This MT torque direction
                idxs_bool = ismember(matrix_same_torque, -torque_dir_i, 'rows'); % MTs with the OPPOSITE torque direction
                assert(sum(idxs_bool) == 1); % It has to be a pair with opposite torque
                
                j_mt = find(idxs_bool);
                matrix_opposite_torque = [matrix_opposite_torque; matrix_same_torque(i_mt,:)]; % Append torque direction (1st element)
                idxs_num_opposite_torque = [idxs_num_opposite_torque; [i_mt, j_mt]]; % Append MT indexes
                flag_mt_checked([i_mt, j_mt]) = 1; % Flag as checked
            end
            
            % Step 3. Solve optimization problem: min ||Ax-b||_2^2 s.t. Cx = d
            N_mt_opposite = size(matrix_opposite_torque, 1);
            
            n = N_mt_opposite; % number of variables
            p = 3; % number of constraints
            
            C = matrix_opposite_torque';
            
            A = eye(n);
            b = zeros(n,1);
            
            % Form Karush-Kuhn-Tucker (KKT) system
            O = zeros(p,p);
            E = [A'*A C'; C O];
            [L,U,P] = lu(E);
            
            obj.optim_data.A = A;
            obj.optim_data.b = b;
            obj.optim_data.U = U;
            obj.optim_data.L = L;
            obj.optim_data.P = P;
            obj.optim_data.n = n;
            obj.optim_data.N_mt = N_mt;
            obj.optim_data.N_mt_opposite = N_mt_opposite;
            obj.optim_data.N_mt_same = N_mt_same;
            obj.optim_data.idxs_num_opposite_torque = idxs_num_opposite_torque;
            obj.optim_data.idxs_bool_same_torque = idxs_bool_same_torque;
        end
        
        function obj = func_decompose_control_torque_into_thrusters_optimization_kkt(obj,SC_control_attitude)
            
            % reset
            for j=1:1:obj.num_micro_thruster
                obj.MT_data(j).commanded_thrust = 0;
                obj.MT_data(j).commanded_torque = zeros(3,1);
            end
            
            % Retrieve data
            A = obj.optim_data.A;
            b = obj.optim_data.b;
            U = obj.optim_data.U;
            L = obj.optim_data.L;
            P = obj.optim_data.P;
            n = obj.optim_data.n;
            N_mt = obj.optim_data.N_mt;
            N_mt_opposite = obj.optim_data.N_mt_opposite;
            N_mt_same = obj.optim_data.N_mt_same;
            idxs_num_opposite_torque = obj.optim_data.idxs_num_opposite_torque;
            idxs_bool_same_torque = obj.optim_data.idxs_bool_same_torque;
            
            % Efficient solve
            d = SC_control_attitude.desired_control_torque_MT;
            f = [A'*b; d];
            xz = U\(L\(P*f));
            x_opposite = xz(1:n);
            
            % Step 4. Undo reduction
            x_same = zeros(N_mt_same, 1);
            for i_mt = 1:N_mt_opposite
                idxs_num_i = idxs_num_opposite_torque(i_mt, :);
                x_same(idxs_num_i(1)) = max(0, +x_opposite(i_mt));
                x_same(idxs_num_i(2)) = max(0, -x_opposite(i_mt));
            end
            x = zeros(N_mt, 1);
            for i_mt = 1:N_mt_same
                idxs_bool_i = idxs_bool_same_torque(i_mt, :);
                x(idxs_bool_i) = x_same(i_mt) / sum(idxs_bool_i);
            end
            
            for i=1:1:obj.num_micro_thruster
                obj.MT_data(i).commanded_thrust = x(i);
                obj.MT_data(i).commanded_torque = obj.MT_data(i).thruster_input_array * obj.MT_data(i).commanded_thrust;
                if obj.MT_data(i).commanded_thrust < obj.MT_data(i).minimum_thrust
                    warning('Thruster %d has thrust below minimum', i);
                elseif obj.MT_data(i).commanded_thrust > obj.MT_data(i).maximum_thrust
                    warning('Thruster %d has thrust above maximum', i);
                end
            end
        end
        
        function obj = func_decompose_control_torque_into_thrusters_adhoc(obj,SC_control_attitude)
            
            % Decompose Torque to Create Thrust Array inputs using Ad Hoc
            % steps, we are not checking the resultant force
            
            % reset
            for j=1:1:obj.num_micro_thruster
                obj.MT_data(j).commanded_thrust = 0;
                obj.MT_data(j).commanded_torque = zeros(3,1);
            end
            
            x = zeros(obj.num_micro_thruster,1);
            thruster_input_matrix = [obj.MT_data.thruster_input_array];
            
            for i=1:1:3
                % 3 axes
                
                if SC_control_attitude.desired_control_torque_MT(i) > 0
                    idx_array = find(thruster_input_matrix(i,:)>1e-3);
                    
                else
                    idx_array = find(thruster_input_matrix(i,:)<-1e-3);
                    
                end
                
                for this_idx = idx_array
                    x(this_idx) = (SC_control_attitude.desired_control_torque_MT(i) / (length(idx_array)*thruster_input_matrix(i,this_idx)) );
                end
                
            end
            
            % Store command (thrust and resulting torque)
            for j=1:1:obj.num_micro_thruster
                obj.MT_data(j).commanded_thrust = x(j);
                obj.MT_data(j).commanded_torque = obj.MT_data(j).thruster_input_array*obj.MT_data(j).commanded_thrust;
            end
            
        end
        
        function obj = func_command_thrust(obj, SC_executive, mission_true_time)
            
            
            for i=1:obj.num_micro_thruster
                
                % Bound for max thrust (same bound for all)
                %                     max_command_thrust = max([obj.MT_data.commanded_thrust]);
                %                     max_thrust = min([obj.MT_data.maximum_thrust]);
                %                     if max_command_thrust > max_thrust
                %                         obj.MT_data(i).commanded_thrust = (max_thrust/max_command_thrust)*obj.MT_data(i).commanded_thrust;
                %                     end
                % Bound for max thrust (bound individually)
                if obj.MT_data(i).commanded_thrust > obj.MT_data(i).maximum_thrust
                    obj.MT_data(i).commanded_thrust = obj.MT_data(i).maximum_thrust;
                end
                % Bound for min thrust (bound individually)
                if obj.MT_data(i).commanded_thrust < obj.MT_data(i).minimum_thrust
                    obj.MT_data(i).commanded_thrust = obj.MT_data(i).minimum_thrust;
                end
                
                if obj.MT_data(i).health == 1
                    
                    % True Thrust comand sent to SC_Body
                    obj.MT_data(i).true_commanded_thrust = obj.MT_data(i).commanded_thrust + obj.MT_data(i).thruster_noise*(-1 + 2.*rand(1))';   % add noise to command
                    obj.MT_data(i).control_force_MT = obj.MT_data(i).true_commanded_thrust*obj.MT_data(i).orientation;                           % True thrust vector in Body frame
                    % Actual Torque, that SC knows
                    obj.MT_data(i).control_torque_MT = obj.MT_data(i).thruster_input_array*obj.MT_data(i).true_commanded_thrust;
                    obj.MT_data(i).command_time = SC_executive.time;
                    
                    % Update Power and Data
                    if obj.MT_data(i).commanded_thrust > obj.MT_data(i).minimum_thrust
                        obj.MT_data(i).instantaneous_power_consumed = obj.MT_data(i).instantaneous_power_consumption;
                        obj.MT_data(i).instantaneous_data_generated = obj.MT_data(i).instantaneous_data_volume;
                        obj.MT_data(i).mass_propelant_used = obj.MT_data(i).mass_propelant_used + obj.MT_data(i).true_commanded_thrust/(9.81*obj.MT_data(i).ISP)*mission_true_time.time_step;
                    else
                        obj.MT_data(i).instantaneous_power_consumed = 0;
                        obj.MT_data(i).instantaneous_data_generated = 0;
                    end
                    
                else
                    
                    % This MT is in failure case
                    obj.MT_data(i).true_commanded_thrust = 0;
                    obj.MT_data(i).control_force_MT = zeros(3,1);
                    obj.MT_data(i).control_torque_MT = zeros(3,1);
                    obj.MT_data(i).instantaneous_power_consumed = 0;
                    obj.MT_data(i).instantaneous_data_generated = 0;
                    
                end
                
            end
            
            
            
            
            
        end
        
    end
end

